<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>驿马西方</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-18T15:26:42.758Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lesline</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty</title>
    <link href="http://yoursite.com/2018/10/18/netty/"/>
    <id>http://yoursite.com/2018/10/18/netty/</id>
    <published>2018-10-18T15:25:34.415Z</published>
    <updated>2018-10-18T15:26:42.758Z</updated>
    
    <content type="html"><![CDATA[<p>Netty 是一个异步事件驱动的网络通信层框架，用于快速开发高可用高性能的服务端网络框架与客户端程序，它极大地简化了 TCP 和 UDP 套接字服务器等网络编程。<br><a id="more"></a></p><p>Netty 底层基于 JDK 的 NIO，我们为什么不直接基于 JDK 的 NIO 或者其他NIO框架：<br>1 使用 JDK 自带的 NIO 需要了解太多的概念，编程复杂。<br>2 Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动。<br>3 Netty自带的拆包解包，异常检测等机制让我们从 NIO 的繁重细节中脱离出来，只需关心业务逻辑即可。<br>4 Netty解决了JDK 的很多包括空### 轮询在内的 Bug。<br>5 Netty底层对线程，Selector 做了很多细小的优化，精心设计的 Reactor 线程做到非常高效的并发处理。<br>6 自带各种协议栈，让我们处理任何一种通用协议都几乎不用亲自动手。<br>7 Netty社区活跃，遇到问题随时邮件列表或者 issue。<br>8 Netty已经历各大RPC框架（Dubbo），消息中间件（RocketMQ），大数据通信（Hadoop）框架的广泛的线上验证，健壮性无比强大。</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>IO复用模型：主要使用到了select，poll或epoll，这几个函数也会使进程阻塞，但是和阻塞IO所不同的的，这个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作，多个写操作的IO函数进行检测，直到有数据可读或可写时，才真正调用I/O操作，现在Linux上使用epoll，极大的提升了性到和扩大了单个服务器线程的限制数量。</p><p><img src="https://upload-images.jianshu.io/upload_images/1117220-4967844e12634731.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IO复用模型.png"></p><p>NIO的特点：事件驱动模型、单线程处理多任务、非阻塞I/O，I/O读写不再阻塞，而是返回0、基于block的传输比基于流的传输更高效、更高级的IO函数zero-copy、IO多路复用大大提高了Java网络应用的可伸缩性和实用性。</p><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p>netty实现在原理上没有多大创新，主要是对java nio 做了封装，基于Reactor线程模型进行了实现。大大简化了程序员的编程。</p><p>Reactor线程模型如下：<br><img src="https://upload-images.jianshu.io/upload_images/1117220-a2e632517b9f78b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Reactor线程模型.png"></p><p>netty的具体实现：<br><img src="https://upload-images.jianshu.io/upload_images/1117220-9fe7a9c834667ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="netty的具体实现.png"></p><h3 id="支持的协议"><a href="#支持的协议" class="headerlink" title="支持的协议"></a>支持的协议</h3><p>HTTP, Web Sockets, SPDY, and RTSP codec等协议，也可以自定议协议。<br>相对Tomcat来说，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流。<br>netty完全可以替代servlet。</p><h3 id="Reactor的类比"><a href="#Reactor的类比" class="headerlink" title="Reactor的类比"></a>Reactor的类比</h3><p>举一个银行服务的例子：<br>客户操作：1.接待和填表 （连接）2.办理存取（业务处理）<br>一个柜员处理一个人的业务，柜员要等待客户填表，填表时柜员不能做任何事，这就是BIO；<br>如果单独找一个柜员负责招待和让客户填写表格，填好表格的再让其它柜员接待办理业务，节省的人力就很多。这就NIO。</p><p>假设：客户进入门店-&gt;接待-&gt;填表（1分钟）-&gt; 办理存取业务（1分钟）<br>同步：10个柜员一小时能接待30<em>10=300<br>NIO：一个柜员负责接待和填表、其它9个柜员能接待60</em>9=360<br>可以把一个柜员代表一个线程，这样就可以在同等的线程数下拥有更大的负载；<br>其中单独抽出的柜员就是reactor中的acceptor。</p><hr><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://netty.io/wiki/user-guide-for-4.x.html" target="_blank" rel="noopener">Netty.docs: User guide for 4.x</a></p><p>Netty的书籍：<br>《Netty in Action》<br>《Netty权威指南》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Netty 是一个异步事件驱动的网络通信层框架，用于快速开发高可用高性能的服务端网络框架与客户端程序，它极大地简化了 TCP 和 UDP 套接字服务器等网络编程。&lt;br&gt;
    
    </summary>
    
      <category term="reactor" scheme="http://yoursite.com/categories/reactor/"/>
    
    
  </entry>
  
  <entry>
    <title>html5</title>
    <link href="http://yoursite.com/2018/08/31/html5/"/>
    <id>http://yoursite.com/2018/08/31/html5/</id>
    <published>2018-08-31T01:33:12.000Z</published>
    <updated>2018-08-31T02:07:47.923Z</updated>
    
    <content type="html"><![CDATA[<p>在 Web 应用中，浏览器和服务器之间使用的是请求 / 响应的交互模式。浏览器发出请求，服务器根据收到的请求来生成相应的响应，<br>这种方式的不足之处在于：服务器端产生的数据变化不能及时地通知浏览器，而是需要等到下次请求发出时才能被浏览器获取。对于某些对数据实时性要求很高的应用来说，这种延迟是不能接受的。<br>目前常见的解决办法有不少，主要可以分成两类。</p><ol><li>基于 HTTP 协议：简单轮询、COMET 技术、服务器推送事件(HTML 5 新增)</li><li>基于TCP 协议: WebSocket (HTML 5 新增)<a id="more"></a></li></ol><h2 id="简单轮询"><a href="#简单轮询" class="headerlink" title="简单轮询"></a>简单轮询</h2><p>简易轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</p><h2 id="COMET"><a href="#COMET" class="headerlink" title="COMET"></a>COMET</h2><p>COMET 技术改进了简易轮询的缺点，使用的是长轮询。长轮询的方式在每次请求时，服务器端会保持该连接在一段时间内处于打开状态，而不是在响应完成之后就立即关闭。这样做的好处是在连接处于打开状态的时间段内，服务器端产生的数据更新可以被及时地返回给浏览器。当上一个长连接关闭之后，浏览器会立即打开一个新的长连接来继续请求。<br>这种方式也是对简易轮询一个优化，解决了简易轮询数据通知不及时，以及减少了大量的无效轮询次数。缺点：长期占用连接，丧失了无状态高并发的特点。<br>COMET 技术的实现在服务器端和浏览器端都需要第三方库的支持。并不是 HTML 5 标准的一部分，从兼容标准的角度出发，也不推荐使用.</p><h2 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h2><p>服务器推送事件（Server-sent Events）是 HTML 5 规范中的一个组成部分，可以用来从服务端实时推送数据到浏览器端。相对于与之类似的 COMET 和 WebSocket 技术来说，服务器推送事件的使用更简单，对服务器端的改动也比较小。对于某些类型的应用来说，服务器推送事件是最佳的选择。主要特点：实现自动重连，服务器数据推送。<br><code>text/event-stream :Server-sent Events 规范是 HTML 5 规范的一个组成部分</code></p><blockquote><p>注意：SSE 是单向通道，只能服务器向客户端发送消息，如果客户端需要向服务器发送消息，则需要一个新的 HTTP 请求。</p></blockquote><h3 id="SSE的java实现"><a href="#SSE的java实现" class="headerlink" title="SSE的java实现"></a>SSE的java实现</h3><h4 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">protected void doGet(HttpServletRequest request,</span><br><span class="line">HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">response.setContentType(&quot;text/event-stream&quot;);</span><br><span class="line">response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">// 指定事件标识</span><br><span class="line">response.getWriter().write(&quot;event:me\n&quot;);</span><br><span class="line">// 格式: data: + 数据 + 2个回车</span><br><span class="line">response.getWriter().write(&quot;data:&quot; + i + &quot;\n\n&quot;);</span><br><span class="line">response.getWriter().flush();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.*SECONDS*.sleep(1);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">// 初始化, 参数为url</span><br><span class="line">var sse = new EventSource(&quot;ssh/url&quot;);</span><br><span class="line"></span><br><span class="line">sse.onmessage = function(e) &#123;</span><br><span class="line">console.log(&quot;message&quot;, e.data, e);</span><br><span class="line">&#125;</span><br><span class="line">// 监听指定事件, (就不会进入onmessage了)</span><br><span class="line">sse.addEventListener(&quot;me&quot;, function(e) &#123;</span><br><span class="line">console.log(&quot;me event&quot;, e.data);</span><br><span class="line">// 如果不关闭,会自动重连</span><br><span class="line">if (e.data == 3) &#123;</span><br><span class="line">sse.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>主要参数：</strong><br><strong>event 消息的事件类型</strong>：客户端收到消息时，会在当前的 EventSource 对象上触发一个事件，这个事件的名称就是这个字段的值，如果消息没有这个字段，客户端的 EventSource 对象就会触发默认的 message 事件。<br><strong>id 这条消息的 ID</strong>：客户端接收到消息后，会把这个 ID 作为内部属性 Last-Event-ID，在断开重连 成功后，会把 Last-Event-ID 发送给服务器。<br><strong>data 消息的数据字段</strong>： 客户端会把这个字段解析为字符串，如果一条消息有多个 data 字段，客户端会自动用换行符 连接成一个字符串。<br><strong>retry 指定客户端重连的时间</strong>：只接受整数，单位是毫秒。如果这个值不是整数则会被自动忽略。</p><h3 id="SSE-如何保证数据完整性"><a href="#SSE-如何保证数据完整性" class="headerlink" title="SSE 如何保证数据完整性"></a>SSE 如何保证数据完整性</h3><p>客户端在每次接收到消息时，会把消息的 id 字段作为内部属性 Last-Event-ID 储存起来。SSE 默认支持断线重连机制，在连接断开时会 触发 EventSource 的 error 事件，同时自动重连。再次连接成功时 EventSource 会把 Last-Event-ID 属性作为请求头发送给服务器，这样服务器就可以根据这个 Last-Event-ID 作出相应的处理。</p><blockquote><p>注意：id 字段不是必须的，服务器有可能不会在消息中带上 id 字段，这样子客户端就不会存在 Last-Event-ID 这个属性。所以为了保证数据可靠，我们需要在每条消息上带上 id 字段。</p></blockquote><p>参考：<br><a href="https://www.v2ex.com/t/379577" target="_blank" rel="noopener">SSE：使用 HTTP 做数据推送应用 - V2EX</a></p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p> WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。首次通过HTTP协议建立连接之后，接下来就是完全按照Websocket协议进行交互。</p><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程 - 阮一峰的网络日志</a><br><a href="https://www.cnblogs.com/doudouxiaoye/p/5656681.html" target="_blank" rel="noopener">WebSocket简单介绍 - 肥宅兜 - 博客园</a></p><h2 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h2><p>HTTP1.0的使用的是短连接，每次请求都需要经过三次握手建立一个TCP连接，四次握手断开连接。</p><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><h3 id="HTTP1-1提升性能的手段"><a href="#HTTP1-1提升性能的手段" class="headerlink" title="HTTP1.1提升性能的手段"></a>HTTP1.1提升性能的手段</h3><p>1.持久连接 （keep-alive/persistent connection）<br>2.并行连接<br>3 流水线（Pipelining）</p><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>HTTP1.1开始默认建立的是持久连接（有时叫长连接），即一旦浏览器发起HTTP请求，建立的连接不会请求应答之后立刻断掉。一个连接可以不断传输多个HTTP请求，但是如果上一个请求的响应还未收到，则不能处理下一个请求。</p><blockquote><p>注意：在HTTP1.1中默认开启Connection： keep-alive。</p></blockquote><p>参考：<br><a href="https://blog.csdn.net/jiyiqinlovexx/article/details/50500246" target="_blank" rel="noopener">关于HTTP1.1的长连接 - CSDN博客</a></p><h4 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h4><p>按照默认设定，一个连接中的每一个请求必须等待收到响应后才能发送下一个请求，所以如果复数的资源请求全部在一个连接one by one发送给服务器显然会很慢，而为了弥补这一缺陷，浏览器通常会默认开启多个TCP连接，然后再根据每个连接的状态在其中依次发送数据请求，而且客户端有权任意关闭超发的连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Firefox 2:  2</span><br><span class="line">Firefox 3+: 6</span><br><span class="line">Opera 9.26: 4</span><br><span class="line">Opera 12:   6</span><br><span class="line">Safari 3:   4</span><br><span class="line">Safari 5:   6</span><br><span class="line">IE 7:       2</span><br><span class="line">IE 8:       6</span><br><span class="line">IE 10:      8</span><br><span class="line">Chrome:     6</span><br></pre></td></tr></table></figure></p><h4 id="流水线（Pipelining）"><a href="#流水线（Pipelining）" class="headerlink" title="流水线（Pipelining）"></a>流水线（Pipelining）</h4><p>可以在一个连接中发送多个请求不必等待前一个请求返回。但这项技术比较容易踩坑，所以主流面向用户的浏览器，这项技术是被默认关闭。 </p><h3 id="HTTP1-1存在效率问题"><a href="#HTTP1-1存在效率问题" class="headerlink" title="HTTP1.1存在效率问题"></a>HTTP1.1存在效率问题</h3><p>如上面所说，在HTTP1.1中是默认开启了Keep-Alive，他解决了多次连接的问题，但是依然有两个效率上的问题：</p><ol><li>串行的文件传输。当请求a、b文件时，b文件只能等待，必须等a文件传输完成后，b文件才能传输，独占了网络。</li><li>连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。</li></ol><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>HTTP/2有四大特性：二进制格式（Binary Format）、头部压缩、服务端推送(Server Push)、多路复用。</p><h3 id="多路复用（MultiPlexing）"><a href="#多路复用（MultiPlexing）" class="headerlink" title="多路复用（MultiPlexing）"></a>多路复用（MultiPlexing）</h3><p>即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><h3 id="服务端推送（server-push）"><a href="#服务端推送（server-push）" class="headerlink" title="服务端推送（server push）"></a>服务端推送（server push）</h3><p>同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用H2。</p><blockquote><p>注意：HTTP/2引入了服务器推送，它使服务器能够主动发送资源到客户端缓存。但是，它并不允许将数据推送到客户端应用程序本身。服务器推送只能由浏览器处理，并且不会在应用程序代码中弹出，这意味着应用程序没有API来获取这些事件的通知。</p></blockquote><h3 id="HTTP1-1存在效率问题-1"><a href="#HTTP1-1存在效率问题-1" class="headerlink" title="HTTP1.1存在效率问题"></a>HTTP1.1存在效率问题</h3><ol><li>对于第一个问题：能够把HTTP消息分解成交错的帧,并在另一端组装它们是HTTP/2中一个非常重要的提高。文件传输不再串行，由于所有请求的消息都可分解，那么某一个请求不用等待别一个请求的结束再发送。</li><li>对于第二个问题：HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍！</li></ol><p>参考：<br><a href="https://www.cnblogs.com/wujiaolong/p/5172e1f7e9924644172b64cb2c41fc58.html" target="_blank" rel="noopener">HTTP、HTTP2 - wujiaolong - 博客园</a><br><a href="https://segmentfault.com/a/1190000011172823" target="_blank" rel="noopener">浅析HTTP/2的多路复用 - 奥巴驴 - SegmentFault 思否</a><br><a href="http://www.52im.net/thread-336-1-1.html" target="_blank" rel="noopener">Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE-网页端IM开发/专项技术区 - 即时通讯开发者社区!</a><br><a href="http://www.52im.net/thread-335-1-1.html" target="_blank" rel="noopener">SSE技术详解：一种全新的HTML5服务器推送事件技术-网页端IM开发/专项技术区 - 即时通讯开发者社区!</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Web 应用中，浏览器和服务器之间使用的是请求 / 响应的交互模式。浏览器发出请求，服务器根据收到的请求来生成相应的响应，&lt;br&gt;这种方式的不足之处在于：服务器端产生的数据变化不能及时地通知浏览器，而是需要等到下次请求发出时才能被浏览器获取。对于某些对数据实时性要求很高的应用来说，这种延迟是不能接受的。&lt;br&gt;目前常见的解决办法有不少，主要可以分成两类。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于 HTTP 协议：简单轮询、COMET 技术、服务器推送事件(HTML 5 新增)&lt;/li&gt;
&lt;li&gt;基于TCP 协议: WebSocket (HTML 5 新增)
    
    </summary>
    
      <category term="HTML5" scheme="http://yoursite.com/categories/HTML5/"/>
    
    
  </entry>
  
  <entry>
    <title>java8-lambda</title>
    <link href="http://yoursite.com/2018/08/25/java8-lambda/"/>
    <id>http://yoursite.com/2018/08/25/java8-lambda/</id>
    <published>2018-08-25T15:06:03.000Z</published>
    <updated>2018-08-25T15:06:03.953Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试整理</title>
    <link href="http://yoursite.com/2018/08/25/face/"/>
    <id>http://yoursite.com/2018/08/25/face/</id>
    <published>2018-08-25T15:05:14.098Z</published>
    <updated>2018-08-25T15:07:29.399Z</updated>
    
    <content type="html"><![CDATA[<p>年前换工作，进行了面试，准备面试的过程学习到了一些东西，在此整理出来，供大家参考。<br><a id="more"></a></p><h2 id="一：算法问题"><a href="#一：算法问题" class="headerlink" title="一：算法问题"></a>一：算法问题</h2><h3 id="1：各排序及时间复杂度（必问）"><a href="#1：各排序及时间复杂度（必问）" class="headerlink" title="1：各排序及时间复杂度（必问）"></a>1：各排序及时间复杂度（必问）</h3><hr><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">冒泡排序</th><th style="text-align:center">合并排序</th><th style="text-align:right">快速排序</th></tr></thead><tbody><tr><td style="text-align:left">最坏时间复杂度</td><td style="text-align:left">n2</td><td style="text-align:center">nlog(n)</td><td style="text-align:right">n2</td></tr><tr><td style="text-align:left">最好时间复杂度</td><td style="text-align:left">n2/n</td><td style="text-align:center">nlog(n)</td><td style="text-align:right">nlog(n)</td></tr><tr><td style="text-align:left">平均时间复杂度</td><td style="text-align:left">n2</td><td style="text-align:center">nlog(n)</td><td style="text-align:right">nlog(n)</td></tr><tr><td style="text-align:left">最坏空间复杂度</td><td style="text-align:left">1</td><td style="text-align:center">n</td><td style="text-align:right">log(n)</td></tr></tbody></table><p>上面表格中，为了便于输入，n2表示n的2次方<br>有些公司（美团、小米）会让写代码，一般能写出快排就行了。</p><h2 id="Big-O-Algorithm-Complexity-Cheat-Sheet-Know-Thy-Complexities-ericdrowell"><a href="#Big-O-Algorithm-Complexity-Cheat-Sheet-Know-Thy-Complexities-ericdrowell" class="headerlink" title="Big-O Algorithm Complexity Cheat Sheet (Know Thy Complexities!) @ericdrowell"></a><a href="http://bigocheatsheet.com" target="_blank" rel="noopener">Big-O Algorithm Complexity Cheat Sheet (Know Thy Complexities!) @ericdrowell</a></h2><p>代码如下：<br><a href="https://www.jianshu.com/p/7e3c7f3086b1" target="_blank" rel="noopener">冒泡排序 - 简书</a><br><a href="https://www.jianshu.com/p/4ea663346c25" target="_blank" rel="noopener">快速排序 - 简书</a><br><a href="https://www.jianshu.com/p/73c337206bad" target="_blank" rel="noopener">归并排序 - 简书</a></p><h3 id="2：链表反转（有些公司会让手写）"><a href="#2：链表反转（有些公司会让手写）" class="headerlink" title="2：链表反转（有些公司会让手写）"></a>2：链表反转（有些公司会让手写）</h3><p><a href="https://www.cnblogs.com/byrhuangqiang/p/4311336.html" target="_blank" rel="noopener">单链表反转总结篇 - BYRHuangQiang - 博客园</a></p><h3 id="3：动态规划"><a href="#3：动态规划" class="headerlink" title="3：动态规划"></a>3：动态规划</h3><p>动态规划问题有很多，这里只讨论两个问题：</p><ol><li>取子数组的最大和</li><li>01背包问题<br><a href="https://www.jianshu.com/p/ef4f5995d363" target="_blank" rel="noopener">动太规划 - 简书</a><br>其它算法参考<br><a href="http://blog.csdn.net/changyuanchn/article/details/51476281" target="_blank" rel="noopener">五大常用算法总结 - changyuanchn的专栏 - CSDN博客</a><h3 id="3：树结构（了解即可）"><a href="#3：树结构（了解即可）" class="headerlink" title="3：树结构（了解即可）"></a>3：树结构（了解即可）</h3><a href="https://www.jianshu.com/p/fbfdcb15c1f2" target="_blank" rel="noopener">树结构 - 简书</a><h3 id="3：Paxos算法（加分项）"><a href="#3：Paxos算法（加分项）" class="headerlink" title="3：Paxos算法（加分项）"></a>3：Paxos算法（加分项）</h3>本人总结在<a href="https://www.jianshu.com/p/634cac6479e8" target="_blank" rel="noopener">系统一致性 - 简书</a>中的『 2.3 分布式数据一致性的研究现状 』一章，由于paxos相对较为复杂，可参考论文及其它网上资源<br><a href="https://www.jianshu.com/p/06a477a576bf" target="_blank" rel="noopener">Paxos 算法浅析 - 简书</a><br><a href="http://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">Raft 为什么是更易理解的分布式一致性算法 - mindwind - 博客园</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=403582309&amp;idx=1&amp;sn=80c006f4e84a8af35dc8e9654f018ace&amp;scene=1&amp;srcid=0119gtt2MOru0Jz4DHA3Rzqy&amp;key=710a5d99946419d927f6d5cd845dc9a72ff3d652a8e66f0ddf87d91262fd262f61f63660690d2d5da76a44a29e155610&amp;ascene=0&amp;uin=MjA1MDk3Njk1&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.1+build(15B42" target="_blank" rel="noopener">架构师需要了解的Paxos原理、历程及实战</a>&amp;version=11020201&amp;pass_ticket=bhstP11nRHvorVXvQ4pt9fzB9Vdzj5sSRBe84783gsg%3D)</li></ol><h2 id="二：JAVA基础"><a href="#二：JAVA基础" class="headerlink" title="二：JAVA基础"></a>二：JAVA基础</h2><h3 id="1：String-类的intern方法"><a href="#1：String-类的intern方法" class="headerlink" title="1：String 类的intern方法"></a>1：String 类的intern方法</h3><p><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern -</a></p><h3 id="2：Hashmap为什么线程不安全，及put过程，扩容过程，死循环产生的过程（必问）"><a href="#2：Hashmap为什么线程不安全，及put过程，扩容过程，死循环产生的过程（必问）" class="headerlink" title="2：Hashmap为什么线程不安全，及put过程，扩容过程，死循环产生的过程（必问）"></a>2：Hashmap为什么线程不安全，及put过程，扩容过程，死循环产生的过程（必问）</h3><p><a href="https://www.jianshu.com/p/1861130943e1" target="_blank" rel="noopener">HashMap实现原理 - 简书</a><br>参考：<br><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">疫苗：Java HashMap的死循环 | | 酷 壳 - CoolShell</a><br><a href="http://blog.csdn.net/a407625470/article/details/71080008" target="_blank" rel="noopener">HashMap多线程死循环问题 - CSDN博客</a><br>注意：HashMap 、ConcurrentHashMap 是看源码最好的入门，有数组、链表、红黑树，最好通读下源码。</p><h3 id="3：java自带的的分析问题工具"><a href="#3：java自带的的分析问题工具" class="headerlink" title="3：java自带的的分析问题工具"></a>3：java自带的的分析问题工具</h3><p>jmap<br>jvisualvm<br>jconsole<br>Jstack简单使用，定位死循环、线程阻塞、死锁等问题<br><a href="https://jingyan.baidu.com/article/4f34706e3ec075e387b56df2.html" target="_blank" rel="noopener">高手是怎么使用jstack精确找到异常代码的_百度经验</a><br><a href="http://ginobefunny.com/post/deep_in_jvm_notes_part3/" target="_blank" rel="noopener">《深入理解Java虚拟机》读书笔记3：虚拟机性能监控与调优实战 | GinoBeFunny</a></p><h3 id="4：如果系统宕机，可以通过分析jvm中的内存对象，查找问题"><a href="#4：如果系统宕机，可以通过分析jvm中的内存对象，查找问题" class="headerlink" title="4：如果系统宕机，可以通过分析jvm中的内存对象，查找问题"></a>4：如果系统宕机，可以通过分析jvm中的内存对象，查找问题</h3><ol><li>jvm设置:-XX:+HeapDumpOnOutOfMemoryError —宕机时dump生成的.hprof文件</li><li>用工具分析:内存分析工具MAT(Memory Analyzer Tool)、IBM HeapAnalyzer<h3 id="5：jdk1-8新特性"><a href="#5：jdk1-8新特性" class="headerlink" title="5：jdk1.8新特性"></a>5：jdk1.8新特性</h3><a href="http://blog.didispace.com/books/java8-tutorial/ch1.html" target="_blank" rel="noopener">Java 8 简明教程 · Java 8简明教程</a><h3 id="6-内存结构和垃圾回收算法及垃圾回收器适用场景"><a href="#6-内存结构和垃圾回收算法及垃圾回收器适用场景" class="headerlink" title="6.内存结构和垃圾回收算法及垃圾回收器适用场景"></a>6.内存结构和垃圾回收算法及垃圾回收器适用场景</h3><a href="https://www.jianshu.com/p/a8f1c506ec81" target="_blank" rel="noopener">jvm总结 - 简书</a><h3 id="7：多线程问题"><a href="#7：多线程问题" class="headerlink" title="7：多线程问题"></a>7：多线程问题</h3>多线程的问题范围比较多，这里列出常面试的两点：<h5 id="1、线程池原理及怎么设置更合理"><a href="#1、线程池原理及怎么设置更合理" class="headerlink" title="1、线程池原理及怎么设置更合理"></a>1、线程池原理及怎么设置更合理</h5><strong>线程池的两个参数解释</strong><br>（<strong>注意：maximumPoolSize是在队列满时才会以此为最大数创建新线程</strong>）：<br><strong>corePoolSize</strong>：线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。<br><strong>maximumPoolSize</strong>：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。<br><strong>设置线程池大小</strong><br>设置线程池大小要考虑是cpu密集型还是io密集型，精细化设置的话还要考虑：线程等待时间、线程CPU时间。<br><a href="http://blog.csdn.net/u011519624/article/details/69263460" target="_blank" rel="noopener">如何合理设置线程池大小 - CSDN博客</a></li></ol><h5 id="2、关键字及工多线程工具类"><a href="#2、关键字及工多线程工具类" class="headerlink" title="2、关键字及工多线程工具类"></a>2、关键字及工多线程工具类</h5><p>ThreadLocal：<a href="http://mp.weixin.qq.com/s/5gkK_dwDPAOrtHYSLsQzUA" target="_blank" rel="noopener">Java面试必问，ThreadLocal终极篇</a><br>volatile:<a href="https://www.jianshu.com/p/506c1e38a922" target="_blank" rel="noopener">面试必问的volatile，你了解多少？ - 简书</a><br>CountDownLatch/CyclicBarrier/Semaphore</p><h3 id="8：NIO-AIO问题"><a href="#8：NIO-AIO问题" class="headerlink" title="8：NIO AIO问题"></a>8：NIO AIO问题</h3><p>实际工作中很少直接使用NIO，面试时问NIO很多情况下会引入netty，netty除了网上相关资料（推荐「占小狼的博客」），可以看『netty权威指南』和『netty实战』</p><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h3 id="Ioc-aop原理"><a href="#Ioc-aop原理" class="headerlink" title="Ioc aop原理"></a>Ioc aop原理</h3><p>待整理</p><h3 id="拦截器是怎么实现"><a href="#拦截器是怎么实现" class="headerlink" title="拦截器是怎么实现"></a>拦截器是怎么实现</h3><p>待整理</p><h3 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h3><p>网上很多</p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="Mybatis与-与-区别（容易记反）"><a href="#Mybatis与-与-区别（容易记反）" class="headerlink" title="Mybatis与$与#区别（容易记反）"></a>Mybatis与$与#区别（容易记反）</h3><p><a href="https://www.cnblogs.com/dato/p/7027949.html" target="_blank" rel="noopener">浅谈 Mybatis中的 ${ } 和 #{ }的区别 - 大头就是我 - 博客园</a></p><h2 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h2><h3 id="1：分库分表"><a href="#1：分库分表" class="headerlink" title="1：分库分表"></a>1：分库分表</h3><p>如何分库分表及sharding-jdbc分库分表后如何实现分页：<br><a href="https://www.jianshu.com/p/ee42aba04a64" target="_blank" rel="noopener">sharding-jdbc 按时间分库分表 - 简书</a></p><h3 id="2：dubbo原理和热部署"><a href="#2：dubbo原理和热部署" class="headerlink" title="2：dubbo原理和热部署"></a>2：dubbo原理和热部署</h3><p>参考dubbo官网<br><a href="http://dubbo.io/" target="_blank" rel="noopener">Overview | DUBBO</a></p><h3 id="3：zookeeper选举算法及分布式锁实现"><a href="#3：zookeeper选举算法及分布式锁实现" class="headerlink" title="3：zookeeper选举算法及分布式锁实现"></a>3：zookeeper选举算法及分布式锁实现</h3><p>参考在<a href="https://www.jianshu.com/p/634cac6479e8" target="_blank" rel="noopener">系统一致性 - 简书</a>中的『 2.3.2 Paxos实践应用-&gt;ZAB协议-&gt;选主阶段（Leader election）』一章<br>排它锁：建临时节点<br>同享锁：建临时顺序节点（具体可参考&lt;从paxos到zookeeper&gt;一书）</p><h3 id="4：redis数据结构及分布式锁的实现方式"><a href="#4：redis数据结构及分布式锁的实现方式" class="headerlink" title="4：redis数据结构及分布式锁的实现方式"></a>4：redis数据结构及分布式锁的实现方式</h3><p><a href="https://www.jianshu.com/p/da41fe072d11" target="_blank" rel="noopener">redis分布式锁实现 - 简书</a><br><strong>单机实现：</strong><br>通过set命令加NX/PX参数实现加锁<br>jedis.set(lockKey, requestId, “NX”, “PX”, expireTime);<br>requestId：可为UUID，删除时使用<br>通过del命令解锁：<br>String script = “if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end”;<br>Lua脚本调用保证命令的原子性<br>通过判断requestId（可为UUID），是否为本线程，防止其它线程误删。<br><strong>集群实现：</strong><br>Redlock算法：类似paxos算法，拥有N个Redis master节点的集群，只有超过半数的结点获取锁成功后，认为锁成功。<br><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis – Redis</a><br><a href="http://ifeve.com/redis-lock/" target="_blank" rel="noopener">《Redis官方文档》用Redis构建分布式锁 | 并发编程网 – ifeve.com</a></p><h3 id="5：mq如何保证不丢失消息"><a href="#5：mq如何保证不丢失消息" class="headerlink" title="5：mq如何保证不丢失消息"></a>5：mq如何保证不丢失消息</h3><p>mq信息要固化到硬盘或数据库<br>可参考<a href="https://www.jianshu.com/p/634cac6479e8" target="_blank" rel="noopener">系统一致性 - 简书</a>中的『 2.2.5事件驱动模式 』一章</p><h3 id="6：更新缓存与db同步"><a href="#6：更新缓存与db同步" class="headerlink" title="6：更新缓存与db同步"></a>6：更新缓存与db同步</h3><p>缓存与db属于不同的两个系统，我们知道绝对的数据一致性是不可以的，重点是如何保证最终的一致性，而不影响使用<br>缓存和db的读写先后问题网上有很多讨论，实际应用中各种方式都有，可以确定的原则有两点：<br>1、为了防止空值信息每次都击穿缓存到数据库，增加NullObject(空对象）：如果一个查询在缓存中没有，在数据库中也没有，这样每次都会对击穿数据库进行查询，造成DB负载过大<br>2、尽量设置过期时间，缓存资源有限，防止无效数据一直占用资源。当然也看到有些特例，有些场景面要让数据一直在缓存中，可能通过定时任务，在缓存失效前重置失效时间。</p><h3 id="7：Redis与Memcached区别："><a href="#7：Redis与Memcached区别：" class="headerlink" title="7：Redis与Memcached区别："></a>7：Redis与Memcached区别：</h3><p>1: Memcached 只支持key/value；Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><blockquote><p>redis 哈希（散列）： 相当于hashmap<br>eg:HSET key field value(HSET car price 500)<br>redis 列表： 相当于 对队queue<br>eg:LPUSH key value(LPUSH numbers 1)<br>redis 集合： 相当于set<br>eg:SADD key member (SADD letters a)<br>redis 有序集合：相当于sorted set:加入分数，通过散列表和跳跃表实现<br>eg:zadd key score member(ZADD scordboard 89 tom)</p></blockquote><p>2: 在Redis中，并不是所有的数据都一直存储在内存中的，Memcached是。<br>3：redis可以定期保存到磁盘（持久化），Memcached不能。<br>4：Memcached是多线程，非阻塞IO复用的网络模型，Redis使用单线程的IO复用模型。<br>还有其它区别，具体搜索网上资料</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="mysql不同引擎的区别，数据结构，事务隔离级别以及如何实现隔离"><a href="#mysql不同引擎的区别，数据结构，事务隔离级别以及如何实现隔离" class="headerlink" title="mysql不同引擎的区别，数据结构，事务隔离级别以及如何实现隔离"></a>mysql不同引擎的区别，数据结构，事务隔离级别以及如何实现隔离</h3><p><a href="https://www.jianshu.com/p/844fa04ee031" target="_blank" rel="noopener">数据库隔离级别 - 简书</a></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>sql优化、索引、组合索引相关</p><h2 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h2><p>一般做后端的前端都较弱，所有在面试官在问前端知识时，你可以回答解题的思路，具体函数名、参数什么的网上搜索相关开发手册就行。</p><h3 id="js闭包"><a href="#js闭包" class="headerlink" title="js闭包"></a>js闭包</h3><p>这里特别提下闭包，毕竟这点跟java有很大区别<br><a href="https://kb.cnblogs.com/page/110782/" target="_blank" rel="noopener">Javascript闭包——懂不懂由你，反正我是懂了<em>知识库</em>博客园</a><br><a href="https://www.cnblogs.com/ywqbj/p/5822644.html" target="_blank" rel="noopener">Java8闭包 - yanweiqi - 博客园</a><br><a href="http://blog.csdn.net/yztbydh/article/details/76270708" target="_blank" rel="noopener">闭包(Java中的闭包) - CSDN博客</a></p><h2 id="开放性问题："><a href="#开放性问题：" class="headerlink" title="开放性问题："></a>开放性问题：</h2><h3 id="1、看了哪些书"><a href="#1、看了哪些书" class="headerlink" title="1、看了哪些书"></a>1、看了哪些书</h3><h3 id="2、遇到哪些难题，怎么解决的"><a href="#2、遇到哪些难题，怎么解决的" class="headerlink" title="2、遇到哪些难题，怎么解决的"></a>2、遇到哪些难题，怎么解决的</h3><h3 id="3、哪方面你最擅长，讲一下-你有什么优势"><a href="#3、哪方面你最擅长，讲一下-你有什么优势" class="headerlink" title="3、哪方面你最擅长，讲一下/你有什么优势"></a>3、哪方面你最擅长，讲一下/你有什么优势</h3><p>这些问题较为开放，面试次数多了就有经验了，不过尽量还是提前组织一下语言。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><h3 id="推荐书籍："><a href="#推荐书籍：" class="headerlink" title="推荐书籍："></a>推荐书籍：</h3><ol><li>java并发编程实战（重理论）</li><li>java并发编程的艺术（重使用）</li><li>spring源码深度解析</li><li>Spring实战(Spring Boot实战）</li><li>重构</li><li>代码整洁之道<br>还有其它书籍，但这几本看时最为舒畅，本人以为好的书满足两个条件：一是问题讲清楚，二是用最简单的方式进行讲述。这几本满足这两个条件。<h3 id="网站及博客"><a href="#网站及博客" class="headerlink" title="网站及博客"></a>网站及博客</h3>推荐一个网站、一个博客，特别是占小狼的博客，里面即有技术的总结，还有一些方法的推荐，有空尽量都过一遍：<br><a href="https://tech.meituan.com/" target="_blank" rel="noopener">https://tech.meituan.com/</a><br><a href="https://www.jianshu.com/u/90ab66c248e6" target="_blank" rel="noopener">占小狼 - 简书</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年前换工作，进行了面试，准备面试的过程学习到了一些东西，在此整理出来，供大家参考。&lt;br&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>博客搭建</title>
    <link href="http://yoursite.com/2018/08/25/hexo/"/>
    <id>http://yoursite.com/2018/08/25/hexo/</id>
    <published>2018-08-25T15:04:33.574Z</published>
    <updated>2018-08-25T15:06:50.909Z</updated>
    
    <content type="html"><![CDATA[<p>hexo搭建相对简单，并且有丰富的主题。<br><a id="more"></a></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>安装node<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nodejs安装</span><br><span class="line">1、访问nodejs官网，点击蓝色选框区域稳定版，</span><br><span class="line">并下载https://nodejs.org/en/</span><br><span class="line">2、安装完成后打开终端，输入 </span><br><span class="line">npm -v </span><br><span class="line">node -v </span><br><span class="line">两个命令，如下图出现版本信息，说明安装成功。</span><br></pre></td></tr></table></figure></li></ol><p><a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">Node.js 安装配置 | 菜鸟教程</a></p><ol start="2"><li>安装hexo<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;postName&quot; #新建文章</span><br><span class="line">$ hexo new page &quot;pageName&quot;#新建页面</span><br><span class="line"></span><br><span class="line">常用简写</span><br><span class="line">$ hexo n == hexo new</span><br><span class="line">$ hexo g == hexo generate</span><br><span class="line">$ hexo s == hexo server</span><br><span class="line">$ hexo d == hexo deploy</span><br><span class="line"></span><br><span class="line">$ hexo d -g #生成部署</span><br><span class="line">$ hexo s -g #生成预览</span><br></pre></td></tr></table></figure><h3 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、下载主题到themes/next目录</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line">2、修改_config.yml主题设置</span><br><span class="line">theme: next</span><br><span class="line">3、进入站点根目录/themes/next/_config.yml</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">Hexo的Next主题详细配置 - 简书</a></p><h3 id="设置ssh"><a href="#设置ssh" class="headerlink" title="设置ssh"></a>设置ssh</h3><p><a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a></p><p><img src="%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/6E468444-7658-4F23-AA45-3ADEF22B0FFD.png" alt=""></p><h3 id="绑定域名："><a href="#绑定域名：" class="headerlink" title="绑定域名："></a>绑定域名：</h3><ol><li>申请域名<br><a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">域名注册<em>虚拟主机</em>云服务器_企业邮箱-万网-阿里云旗下品牌</a><br><img src="%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/FE6DB3C9-D45E-49B9-858B-27BC7DA4DF2C.png" alt=""></li></ol><blockquote><p><a href="http://lesline.top.com/" target="_blank" rel="noopener">http://lesline.top.com/</a><br><a href="http://lesline.github.io/" target="_blank" rel="noopener">http://lesline.github.io/</a>  </p><ol start="2"><li>增加文件：<br>/Users/zhangshaolin/git/hexo/blog/source/CNAME<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lesline.top</span><br></pre></td></tr></table></figure></li></ol></blockquote><ol start="3"><li>blog配置文件_config.yml下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lesline/lesline.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li></ol><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>Hexo Next 更换scheme，本地查看成功，部署后访问依然未变化？<br>先clean 再deploy<br>hexo clean<br>hexo g<br>hexo d</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://tengj.top/categories/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97/" target="_blank" rel="noopener">Category: hexo干货系列 | 嘟嘟独立博客</a><br><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">手把手教你使用Hexo + Github Pages搭建个人独立博客 | 令狐葱@前端笔记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo搭建相对简单，并且有丰富的主题。&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>GIT 分支管理</title>
    <link href="http://yoursite.com/2018/08/09/git-branch/"/>
    <id>http://yoursite.com/2018/08/09/git-branch/</id>
    <published>2018-08-09T01:09:24.000Z</published>
    <updated>2018-08-09T01:13:05.691Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考阿里与京东的分支管理做了一下整理。<br><a id="more"></a></p><p>参考：<br><a href="https://mp.weixin.qq.com/s/JsBX3UPgZL_HUOTCIopr_A" target="_blank" rel="noopener">在阿里，我们如何管理代码分支？</a><br><a href="https://www.cnblogs.com/sloong/p/5868292.html" target="_blank" rel="noopener">GitHub Flow  &amp; Git Flow  基于Git 的两种协作开发模式 - sloong - 博客园</a></p><h2 id="TrunkBased-模式：持续集成"><a href="#TrunkBased-模式：持续集成" class="headerlink" title="TrunkBased 模式：持续集成"></a>TrunkBased 模式：持续集成</h2><p><a href="https://paulhammant.com/2013/04/05/what-is-trunk-based-development/" target="_blank" rel="noopener">What is Trunk-Based Development?</a><br><a href="http://www.ruanyifeng.com/blog/2016/07/google-monolithic-source-repository.html" target="_blank" rel="noopener">谷歌的代码管理 - 阮一峰的网络日志</a></p><p>TrunkBased 模式是持续集成思想所崇尚的工作方式，它由单个主干分支和许多发布分支组成，每个发布分支在特定版本的提交点上从主干创建出来，用来进行上线部署和 Hotfix。<br>不能满足多版本并行开发，主要用在不需要同时维护多个历史版本的 SaaS 型项目，特别是经过微服务改造的各种小型服务上。<br>OneFlow 模式：参考了 TrunkBased 的许多思想，对操作流程做了更严格的定义，增加了 Hotfix 分支等内容。<br>多主干模式：通常是双主干，固定的开发分支和固定的发布分支，算是 TrunkBased 采用固定发布分支的特例。<br>GithubFlow 模式：在 TrunkBased 的基础上，增加了个人仓库和 Pull Request 合并代码的操作。</p><h2 id="GitFlow模式：管理需求"><a href="#GitFlow模式：管理需求" class="headerlink" title="GitFlow模式：管理需求"></a>GitFlow模式：管理需求</h2><p><a href="https://segmentfault.com/a/1190000002918123" target="_blank" rel="noopener">深入理解学习Git工作流（git-workflow-tutorial） - 程序生涯 - SegmentFault 思否</a><br>GitFlow模式相对强大：</p><h3 id="应用一："><a href="#应用一：" class="headerlink" title="应用一："></a>应用一：</h3><p>1 master分支<br>主分支，产品的功能全部实现后，最终在master分支对外发布。<br>2 develop分支<br>开发分支，基于master分支克隆，产品的编码工作在此分支进行。<br>3 release分支<br>测试分支，基于delevop分支克隆，产品编码工作完成后，发布到本分支测试，测试过程中发现的小bug直接在本分支进行修复，修复完成后合并到develop分支。本分支属于临时分支，目的实现后可删除分支。<br>4 bugfix分支<br>Bug修复分支，基于master分支或发布的里程碑Tag克隆，主要用于修复对外发布的分支，收到客户的Bug反馈后，在此分支进行修复，修复完毕后分别合并到develop分支和master分支。本分支属于临时分支，目的实现后可删除分支。<br>5 feature分支<br>功能特征分支，基于develop分支克隆，主要用于多人协助开发场景或探索性功能验证场景，功能开发完毕后合并到develop分支。feature分支可创建多个，属于临时分支，目的实现后可删除分支。<br><img src="https://upload-images.jianshu.io/upload_images/1117220-d842d5aa6070b43b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gitflow模型.png"></p><h4 id="主要问题有："><a href="#主要问题有：" class="headerlink" title="主要问题有："></a>主要问题有：</h4><p>::1、如果测试后不上线，Develop分支与线上分支不一致，如果需要develop分支与master一致就需要频繁重建develop分支或回滚。::<br>::2、另外release merge到Master时，代码冲突严重。::</p><h3 id="应用二："><a href="#应用二：" class="headerlink" title="应用二："></a>应用二：</h3><p>与应用一的区别是：建立发布分支用于发布，发布后合并master。<br>1、共一个主干分支master<br>2、N个特性分支==N个发布分支（特性分支开发完成后，直接转测，直接转为发布分支）<br>3、不定期的更新主干分支</p><h4 id="主要问题有：-1"><a href="#主要问题有：-1" class="headerlink" title="主要问题有："></a>主要问题有：</h4><p>::1、主干分支常常跟不上线上环境的代码::<br>::2、大量的合并突冲，集成测试不友好::</p><h2 id="TrunkBased与GitFlow比较："><a href="#TrunkBased与GitFlow比较：" class="headerlink" title="TrunkBased与GitFlow比较："></a>TrunkBased与GitFlow比较：</h2><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p> TrunkBased “易于持续集成” ; GitFlow “易于管理需求”</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>TrunkBased缺点：不能很好支持多版本的并行开发<br>GitFlow的问题：合并冲突</p><h2 id="阿里分支管理AoneFlow"><a href="#阿里分支管理AoneFlow" class="headerlink" title="阿里分支管理AoneFlow"></a>阿里分支管理AoneFlow</h2><p>   在 AoneFlow 上你能看到许多其他分支模式的影子。它基本上兼顾了 TrunkBased 的“易于持续集成”和 GitFlow 的“易于管理需求”特点，同时规避掉 GitFlow 的那些繁文缛节。<br><img src="https://upload-images.jianshu.io/upload_images/1117220-1beeec959db3711a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AoneFlow.jpg"></p><p><strong>1、开始工作前，从主干创建特性分支。</strong><br><img src="https://upload-images.jianshu.io/upload_images/1117220-3445f8c9310f4876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AoneFlow-add feature.png"></p><p><strong>2、通过合并特性分支，形成发布分支。</strong><br><img src="https://upload-images.jianshu.io/upload_images/1117220-5a675e4c836c65bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AoneFlow-add-release.png"></p><p><strong>3、发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支关联的特性分支。</strong><br><img src="https://upload-images.jianshu.io/upload_images/1117220-7e1cfb6f2e70476f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AoneFlow-merge master.png"></p><h2 id="京东分支管理："><a href="#京东分支管理：" class="headerlink" title="京东分支管理："></a>京东分支管理：</h2><h4 id="分支分类："><a href="#分支分类：" class="headerlink" title="分支分类："></a>分支分类：</h4><p>master：主分支，与线上保持一致。永久保留。<br>dev：开发分支，相对稳定分支。永久保留。dev分支与master强一致<br>dev-pretest ： 测试和预上线分支，必要的时候删除从dev拉取。<br>feat-人名全拼或者姓名首字母-功能描述： 功能分支。如; feat-sunweiwei-cancelorder或者feat-sww-cancelorder，标注开发人员+该分支的功能。用完即删。<br>hotfox-人名全拼或者姓名首字母-功能描述：线上bug修复分支。如：hotfix-sunweiwei-orderpay或者feat-sww-orderpay，标注开发人员+该分支处理的问题。用完即删。<br>分支名称统一都是小写字母。</p><p><img src="https://upload-images.jianshu.io/upload_images/1117220-755aaf367d450122.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="jd.jpg"></p><h3 id="京东与阿里的比较"><a href="#京东与阿里的比较" class="headerlink" title="京东与阿里的比较"></a>京东与阿里的比较</h3><p>相同：都从主干拉取分支，再合并特性分支，减少了合并冲突<br>不同：京东是直接在master分支上发布，阿里是新建发布分支，发布成功后合并到master，<br>两种方式导致的结果是：阿里支持“修改历史版本bug”的功能，京东不支持。</p><p>  ::总的来说，京东偏向TrunkBased 模式，阿里偏向Gitflow模式，由于京东模式缺少明确的发布分支，只在主干分支上发布，导致不支持多版本，如果要修改历史版本的bug，只能升级到最新版本。::</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>::1、对于微服务中小型服务（或只是一个jar工具包），这种修改后立刻可以上线使用，且不影响线上服务的情况，用TrunkBased 模式即可::<br>::2、如果系统不支持多版本修复（需要修复升级到最新版本即可），使用京东方式即可。如果有多版本支持使用阿里方式。::</p><p>以上讨论基于如下需求：<br>1、多功能同时测试<br>2、测试后可能不上线</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文参考阿里与京东的分支管理做了一下整理。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo_plug</title>
    <link href="http://yoursite.com/2018/08/09/hexo-plug/"/>
    <id>http://yoursite.com/2018/08/09/hexo-plug/</id>
    <published>2018-08-09T00:25:54.000Z</published>
    <updated>2018-08-09T00:25:54.910Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
