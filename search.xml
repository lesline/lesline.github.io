<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java8-lambda]]></title>
    <url>%2F2018%2F08%2F25%2Fjava8-lambda%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[面试整理]]></title>
    <url>%2F2018%2F08%2F25%2Fface%2F</url>
    <content type="text"><![CDATA[年前换工作，进行了面试，准备面试的过程学习到了一些东西，在此整理出来，供大家参考。 一：算法问题1：各排序及时间复杂度（必问） 冒泡排序 合并排序 快速排序 最坏时间复杂度 n2 nlog(n) n2 最好时间复杂度 n2/n nlog(n) nlog(n) 平均时间复杂度 n2 nlog(n) nlog(n) 最坏空间复杂度 1 n log(n) 上面表格中，为了便于输入，n2表示n的2次方有些公司（美团、小米）会让写代码，一般能写出快排就行了。 Big-O Algorithm Complexity Cheat Sheet (Know Thy Complexities!) @ericdrowell代码如下：冒泡排序 - 简书快速排序 - 简书归并排序 - 简书 2：链表反转（有些公司会让手写）单链表反转总结篇 - BYRHuangQiang - 博客园 3：动态规划动态规划问题有很多，这里只讨论两个问题： 取子数组的最大和 01背包问题动太规划 - 简书其它算法参考五大常用算法总结 - changyuanchn的专栏 - CSDN博客3：树结构（了解即可）树结构 - 简书3：Paxos算法（加分项）本人总结在系统一致性 - 简书中的『 2.3 分布式数据一致性的研究现状 』一章，由于paxos相对较为复杂，可参考论文及其它网上资源Paxos 算法浅析 - 简书Raft 为什么是更易理解的分布式一致性算法 - mindwind - 博客园架构师需要了解的Paxos原理、历程及实战&amp;version=11020201&amp;pass_ticket=bhstP11nRHvorVXvQ4pt9fzB9Vdzj5sSRBe84783gsg%3D) 二：JAVA基础1：String 类的intern方法深入解析String#intern - 2：Hashmap为什么线程不安全，及put过程，扩容过程，死循环产生的过程（必问）HashMap实现原理 - 简书参考：疫苗：Java HashMap的死循环 | | 酷 壳 - CoolShellHashMap多线程死循环问题 - CSDN博客注意：HashMap 、ConcurrentHashMap 是看源码最好的入门，有数组、链表、红黑树，最好通读下源码。 3：java自带的的分析问题工具jmapjvisualvmjconsoleJstack简单使用，定位死循环、线程阻塞、死锁等问题高手是怎么使用jstack精确找到异常代码的_百度经验《深入理解Java虚拟机》读书笔记3：虚拟机性能监控与调优实战 | GinoBeFunny 4：如果系统宕机，可以通过分析jvm中的内存对象，查找问题 jvm设置:-XX:+HeapDumpOnOutOfMemoryError —宕机时dump生成的.hprof文件 用工具分析:内存分析工具MAT(Memory Analyzer Tool)、IBM HeapAnalyzer5：jdk1.8新特性Java 8 简明教程 · Java 8简明教程6.内存结构和垃圾回收算法及垃圾回收器适用场景jvm总结 - 简书7：多线程问题多线程的问题范围比较多，这里列出常面试的两点：1、线程池原理及怎么设置更合理线程池的两个参数解释（注意：maximumPoolSize是在队列满时才会以此为最大数创建新线程）：corePoolSize：线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。设置线程池大小设置线程池大小要考虑是cpu密集型还是io密集型，精细化设置的话还要考虑：线程等待时间、线程CPU时间。如何合理设置线程池大小 - CSDN博客 2、关键字及工多线程工具类ThreadLocal：Java面试必问，ThreadLocal终极篇volatile:面试必问的volatile，你了解多少？ - 简书CountDownLatch/CyclicBarrier/Semaphore 8：NIO AIO问题实际工作中很少直接使用NIO，面试时问NIO很多情况下会引入netty，netty除了网上相关资料（推荐「占小狼的博客」），可以看『netty权威指南』和『netty实战』 springIoc aop原理待整理 拦截器是怎么实现待整理 Spring事务传播机制网上很多 MybatisMybatis与$与#区别（容易记反）浅谈 Mybatis中的 ${ } 和 #{ }的区别 - 大头就是我 - 博客园 中间件应用1：分库分表如何分库分表及sharding-jdbc分库分表后如何实现分页：sharding-jdbc 按时间分库分表 - 简书 2：dubbo原理和热部署参考dubbo官网Overview | DUBBO 3：zookeeper选举算法及分布式锁实现参考在系统一致性 - 简书中的『 2.3.2 Paxos实践应用-&gt;ZAB协议-&gt;选主阶段（Leader election）』一章排它锁：建临时节点同享锁：建临时顺序节点（具体可参考&lt;从paxos到zookeeper&gt;一书） 4：redis数据结构及分布式锁的实现方式redis分布式锁实现 - 简书单机实现：通过set命令加NX/PX参数实现加锁jedis.set(lockKey, requestId, “NX”, “PX”, expireTime);requestId：可为UUID，删除时使用通过del命令解锁：String script = “if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end”;Lua脚本调用保证命令的原子性通过判断requestId（可为UUID），是否为本线程，防止其它线程误删。集群实现：Redlock算法：类似paxos算法，拥有N个Redis master节点的集群，只有超过半数的结点获取锁成功后，认为锁成功。Distributed locks with Redis – Redis《Redis官方文档》用Redis构建分布式锁 | 并发编程网 – ifeve.com 5：mq如何保证不丢失消息mq信息要固化到硬盘或数据库可参考系统一致性 - 简书中的『 2.2.5事件驱动模式 』一章 6：更新缓存与db同步缓存与db属于不同的两个系统，我们知道绝对的数据一致性是不可以的，重点是如何保证最终的一致性，而不影响使用缓存和db的读写先后问题网上有很多讨论，实际应用中各种方式都有，可以确定的原则有两点：1、为了防止空值信息每次都击穿缓存到数据库，增加NullObject(空对象）：如果一个查询在缓存中没有，在数据库中也没有，这样每次都会对击穿数据库进行查询，造成DB负载过大2、尽量设置过期时间，缓存资源有限，防止无效数据一直占用资源。当然也看到有些特例，有些场景面要让数据一直在缓存中，可能通过定时任务，在缓存失效前重置失效时间。 7：Redis与Memcached区别：1: Memcached 只支持key/value；Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 redis 哈希（散列）： 相当于hashmapeg:HSET key field value(HSET car price 500)redis 列表： 相当于 对队queueeg:LPUSH key value(LPUSH numbers 1)redis 集合： 相当于seteg:SADD key member (SADD letters a)redis 有序集合：相当于sorted set:加入分数，通过散列表和跳跃表实现eg:zadd key score member(ZADD scordboard 89 tom) 2: 在Redis中，并不是所有的数据都一直存储在内存中的，Memcached是。3：redis可以定期保存到磁盘（持久化），Memcached不能。4：Memcached是多线程，非阻塞IO复用的网络模型，Redis使用单线程的IO复用模型。还有其它区别，具体搜索网上资料 数据库mysql不同引擎的区别，数据结构，事务隔离级别以及如何实现隔离数据库隔离级别 - 简书 其它sql优化、索引、组合索引相关 前端：一般做后端的前端都较弱，所有在面试官在问前端知识时，你可以回答解题的思路，具体函数名、参数什么的网上搜索相关开发手册就行。 js闭包这里特别提下闭包，毕竟这点跟java有很大区别Javascript闭包——懂不懂由你，反正我是懂了知识库博客园Java8闭包 - yanweiqi - 博客园闭包(Java中的闭包) - CSDN博客 开放性问题：1、看了哪些书2、遇到哪些难题，怎么解决的3、哪方面你最擅长，讲一下/你有什么优势这些问题较为开放，面试次数多了就有经验了，不过尽量还是提前组织一下语言。 推荐推荐书籍： java并发编程实战（重理论） java并发编程的艺术（重使用） spring源码深度解析 Spring实战(Spring Boot实战） 重构 代码整洁之道还有其它书籍，但这几本看时最为舒畅，本人以为好的书满足两个条件：一是问题讲清楚，二是用最简单的方式进行讲述。这几本满足这两个条件。网站及博客推荐一个网站、一个博客，特别是占小狼的博客，里面即有技术的总结，还有一些方法的推荐，有空尽量都过一遍：https://tech.meituan.com/占小狼 - 简书]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2018%2F08%2F25%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo搭建相对简单，并且有丰富的主题。 环境准备 安装node1234567nodejs安装1、访问nodejs官网，点击蓝色选框区域稳定版，并下载https://nodejs.org/en/2、安装完成后打开终端，输入 npm -v node -v 两个命令，如下图出现版本信息，说明安装成功。 Node.js 安装配置 | 菜鸟教程 安装hexoHexo 常用命令1234567891011$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot;#新建页面常用简写$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy$ hexo d -g #生成部署$ hexo s -g #生成预览 更改主题123451、下载主题到themes/next目录git clone https://github.com/theme-next/hexo-theme-next themes/next2、修改_config.yml主题设置theme: next3、进入站点根目录/themes/next/_config.yml Hexo的Next主题详细配置 - 简书 设置sshhttps://github.com/settings/keys 绑定域名： 申请域名域名注册虚拟主机云服务器_企业邮箱-万网-阿里云旗下品牌 http://lesline.top.com/http://lesline.github.io/ 增加文件：/Users/zhangshaolin/git/hexo/blog/source/CNAME1lesline.top blog配置文件_config.yml下1234deploy: type: git repo: git@github.com:lesline/lesline.github.io.git branch: master 问题：Hexo Next 更换scheme，本地查看成功，部署后访问依然未变化？先clean 再deployhexo cleanhexo ghexo d 参考：Category: hexo干货系列 | 嘟嘟独立博客手把手教你使用Hexo + Github Pages搭建个人独立博客 | 令狐葱@前端笔记]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GIT 分支管理]]></title>
    <url>%2F2018%2F08%2F09%2Fgit-branch%2F</url>
    <content type="text"><![CDATA[本文参考阿里与京东的分支管理做了一下整理。 参考：在阿里，我们如何管理代码分支？GitHub Flow &amp; Git Flow 基于Git 的两种协作开发模式 - sloong - 博客园 TrunkBased 模式：持续集成What is Trunk-Based Development?谷歌的代码管理 - 阮一峰的网络日志 TrunkBased 模式是持续集成思想所崇尚的工作方式，它由单个主干分支和许多发布分支组成，每个发布分支在特定版本的提交点上从主干创建出来，用来进行上线部署和 Hotfix。不能满足多版本并行开发，主要用在不需要同时维护多个历史版本的 SaaS 型项目，特别是经过微服务改造的各种小型服务上。OneFlow 模式：参考了 TrunkBased 的许多思想，对操作流程做了更严格的定义，增加了 Hotfix 分支等内容。多主干模式：通常是双主干，固定的开发分支和固定的发布分支，算是 TrunkBased 采用固定发布分支的特例。GithubFlow 模式：在 TrunkBased 的基础上，增加了个人仓库和 Pull Request 合并代码的操作。 GitFlow模式：管理需求深入理解学习Git工作流（git-workflow-tutorial） - 程序生涯 - SegmentFault 思否GitFlow模式相对强大： 应用一：1 master分支主分支，产品的功能全部实现后，最终在master分支对外发布。2 develop分支开发分支，基于master分支克隆，产品的编码工作在此分支进行。3 release分支测试分支，基于delevop分支克隆，产品编码工作完成后，发布到本分支测试，测试过程中发现的小bug直接在本分支进行修复，修复完成后合并到develop分支。本分支属于临时分支，目的实现后可删除分支。4 bugfix分支Bug修复分支，基于master分支或发布的里程碑Tag克隆，主要用于修复对外发布的分支，收到客户的Bug反馈后，在此分支进行修复，修复完毕后分别合并到develop分支和master分支。本分支属于临时分支，目的实现后可删除分支。5 feature分支功能特征分支，基于develop分支克隆，主要用于多人协助开发场景或探索性功能验证场景，功能开发完毕后合并到develop分支。feature分支可创建多个，属于临时分支，目的实现后可删除分支。 主要问题有：::1、如果测试后不上线，Develop分支与线上分支不一致，如果需要develop分支与master一致就需要频繁重建develop分支或回滚。::::2、另外release merge到Master时，代码冲突严重。:: 应用二：与应用一的区别是：建立发布分支用于发布，发布后合并master。1、共一个主干分支master2、N个特性分支==N个发布分支（特性分支开发完成后，直接转测，直接转为发布分支）3、不定期的更新主干分支 主要问题有：::1、主干分支常常跟不上线上环境的代码::::2、大量的合并突冲，集成测试不友好:: TrunkBased与GitFlow比较：优点： TrunkBased “易于持续集成” ; GitFlow “易于管理需求” 缺点：TrunkBased缺点：不能很好支持多版本的并行开发GitFlow的问题：合并冲突 阿里分支管理AoneFlow 在 AoneFlow 上你能看到许多其他分支模式的影子。它基本上兼顾了 TrunkBased 的“易于持续集成”和 GitFlow 的“易于管理需求”特点，同时规避掉 GitFlow 的那些繁文缛节。 1、开始工作前，从主干创建特性分支。 2、通过合并特性分支，形成发布分支。 3、发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支关联的特性分支。 京东分支管理：分支分类：master：主分支，与线上保持一致。永久保留。dev：开发分支，相对稳定分支。永久保留。dev分支与master强一致dev-pretest ： 测试和预上线分支，必要的时候删除从dev拉取。feat-人名全拼或者姓名首字母-功能描述： 功能分支。如; feat-sunweiwei-cancelorder或者feat-sww-cancelorder，标注开发人员+该分支的功能。用完即删。hotfox-人名全拼或者姓名首字母-功能描述：线上bug修复分支。如：hotfix-sunweiwei-orderpay或者feat-sww-orderpay，标注开发人员+该分支处理的问题。用完即删。分支名称统一都是小写字母。 京东与阿里的比较相同：都从主干拉取分支，再合并特性分支，减少了合并冲突不同：京东是直接在master分支上发布，阿里是新建发布分支，发布成功后合并到master，两种方式导致的结果是：阿里支持“修改历史版本bug”的功能，京东不支持。 ::总的来说，京东偏向TrunkBased 模式，阿里偏向Gitflow模式，由于京东模式缺少明确的发布分支，只在主干分支上发布，导致不支持多版本，如果要修改历史版本的bug，只能升级到最新版本。:: 总结：::1、对于微服务中小型服务（或只是一个jar工具包），这种修改后立刻可以上线使用，且不影响线上服务的情况，用TrunkBased 模式即可::::2、如果系统不支持多版本修复（需要修复升级到最新版本即可），使用京东方式即可。如果有多版本支持使用阿里方式。:: 以上讨论基于如下需求：1、多功能同时测试2、测试后可能不上线]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo_plug]]></title>
    <url>%2F2018%2F08%2F09%2Fhexo-plug%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Bear Pro]]></title>
    <url>%2F2018%2F07%2F30%2Fbear%2F</url>
    <content type="text"><![CDATA[这是教程的最后一部分！ 你可以查看 Bear 教程的其他章节，[[欢迎来到 Bear]] 和 [[管理与发布]]。 附加功能你可以在 iPad、iPhone 和 Mac 上使用 Bear 绝大多数的核心功能。 我们希望这独特的工具能让所有人都写出漂亮、整洁的笔记。 如果你想要解锁附加功能和漂亮的主题，并支持 Bear 的持续开发，你可以在应用内订阅 Bear Pro。 订阅 Bear Pro 即可解锁： 在 iPad、iPhone 和 Mac 上的 Bear 之间 同步 所有笔记。 本服务由 CloudKit 提供。 在 [[管理与发布]] 中了解更多关于 Bear 同步和自动保存的内容。 以多种文件格式 导出 并随意发布和分享。 漂亮的主题 - 目前已发布 8 款，更多即将到来。主题为你提供适合、舒服的写作环境，激发你的创造力。 Bear Pro 提供免费试用。 包月订阅服务将赠送你一周免费试用期。 包年订阅服务则赠送一个月免费试用期。 在 iPad、iPhone 和 Mac 上的的应用内设置菜单中了解 Bear Pro。 高级搜索在 Bear 中可即时搜索所有笔记，我们也提供一些 特殊搜索 功能，帮助你找到笔记中的特定内容。 例如，你可以将仍然需要执行的计划任务写在笔记中。 在 iOS 中，将快捷工具条左滑，选择任务按钮（中间有对勾的方块）。 在 Mac 上，则选择格式 -&gt; 待办事项 -&gt; 切换。 现在，在 Bear 的搜索框中，你可以输入 “@todo” 或 “@task” 来查找尚未完成的任务。 同时，你可以通过搜索 “@done” 找到已经完成的任务内容。 Bear 支持的搜索命令有：“@todo、@task、@done、@code、@tagged、@untagged、@files、@images、@attachments”。查看此视频 了解 Bear 的搜索功能如何使用。 最后，你还可以使用英文双引号来精确搜索词语，例如：「”bear is cool”」。 小技巧 🎩Bear 中所有的标签都可长按。 试试看，隐藏键盘后长按#欢迎/pro#包含此标签的所有笔记列表即会出现。 在 Mac 上，你可以隐藏侧边栏和/或笔记列表，享受无干扰的写作环境（iOS 上自动提供这种环境 😉）。 使用 布局选择器 （右下角图标）查看可用选项 反馈 💬我们/希望/了解你的反馈，发信到 bear@shinyfrog.net。 感谢使用 Bear，祝你写作愉快！ 🎉 🐻 🎉]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
