<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html5]]></title>
    <url>%2F2018%2F08%2F31%2Fhtml5%2F</url>
    <content type="text"><![CDATA[在 Web 应用中，浏览器和服务器之间使用的是请求 / 响应的交互模式。浏览器发出请求，服务器根据收到的请求来生成相应的响应，这种方式的不足之处在于：服务器端产生的数据变化不能及时地通知浏览器，而是需要等到下次请求发出时才能被浏览器获取。对于某些对数据实时性要求很高的应用来说，这种延迟是不能接受的。目前常见的解决办法有不少，主要可以分成两类。 基于 HTTP 协议：简单轮询、COMET 技术、服务器推送事件(HTML 5 新增) 基于TCP 协议: WebSocket (HTML 5 新增) 简单轮询简易轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 COMETCOMET 技术改进了简易轮询的缺点，使用的是长轮询。长轮询的方式在每次请求时，服务器端会保持该连接在一段时间内处于打开状态，而不是在响应完成之后就立即关闭。这样做的好处是在连接处于打开状态的时间段内，服务器端产生的数据更新可以被及时地返回给浏览器。当上一个长连接关闭之后，浏览器会立即打开一个新的长连接来继续请求。这种方式也是对简易轮询一个优化，解决了简易轮询数据通知不及时，以及减少了大量的无效轮询次数。缺点：长期占用连接，丧失了无状态高并发的特点。COMET 技术的实现在服务器端和浏览器端都需要第三方库的支持。并不是 HTML 5 标准的一部分，从兼容标准的角度出发，也不推荐使用. SSE服务器推送事件（Server-sent Events）是 HTML 5 规范中的一个组成部分，可以用来从服务端实时推送数据到浏览器端。相对于与之类似的 COMET 和 WebSocket 技术来说，服务器推送事件的使用更简单，对服务器端的改动也比较小。对于某些类型的应用来说，服务器推送事件是最佳的选择。主要特点：实现自动重连，服务器数据推送。text/event-stream :Server-sent Events 规范是 HTML 5 规范的一个组成部分 注意：SSE 是单向通道，只能服务器向客户端发送消息，如果客户端需要向服务器发送消息，则需要一个新的 HTTP 请求。 SSE的java实现后端实现123456789101112131415161718protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/event-stream&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); for (int i = 0; i &lt; 5; i++) &#123; // 指定事件标识 response.getWriter().write(&quot;event:me\n&quot;); // 格式: data: + 数据 + 2个回车 response.getWriter().write(&quot;data:&quot; + i + &quot;\n\n&quot;); response.getWriter().flush(); try &#123; TimeUnit.*SECONDS*.sleep(1); &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; 前端实现12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; // 初始化, 参数为url var sse = new EventSource(&quot;ssh/url&quot;); sse.onmessage = function(e) &#123; console.log(&quot;message&quot;, e.data, e); &#125; // 监听指定事件, (就不会进入onmessage了) sse.addEventListener(&quot;me&quot;, function(e) &#123; console.log(&quot;me event&quot;, e.data); // 如果不关闭,会自动重连 if (e.data == 3) &#123; sse.close(); &#125; &#125;); &lt;/script&gt; 主要参数：event 消息的事件类型：客户端收到消息时，会在当前的 EventSource 对象上触发一个事件，这个事件的名称就是这个字段的值，如果消息没有这个字段，客户端的 EventSource 对象就会触发默认的 message 事件。id 这条消息的 ID：客户端接收到消息后，会把这个 ID 作为内部属性 Last-Event-ID，在断开重连 成功后，会把 Last-Event-ID 发送给服务器。data 消息的数据字段： 客户端会把这个字段解析为字符串，如果一条消息有多个 data 字段，客户端会自动用换行符 连接成一个字符串。retry 指定客户端重连的时间：只接受整数，单位是毫秒。如果这个值不是整数则会被自动忽略。 SSE 如何保证数据完整性客户端在每次接收到消息时，会把消息的 id 字段作为内部属性 Last-Event-ID 储存起来。SSE 默认支持断线重连机制，在连接断开时会 触发 EventSource 的 error 事件，同时自动重连。再次连接成功时 EventSource 会把 Last-Event-ID 属性作为请求头发送给服务器，这样服务器就可以根据这个 Last-Event-ID 作出相应的处理。 注意：id 字段不是必须的，服务器有可能不会在消息中带上 id 字段，这样子客户端就不会存在 Last-Event-ID 这个属性。所以为了保证数据可靠，我们需要在每条消息上带上 id 字段。 参考：SSE：使用 HTTP 做数据推送应用 - V2EX WebSocket WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。首次通过HTTP协议建立连接之后，接下来就是完全按照Websocket协议进行交互。 参考：WebSocket 教程 - 阮一峰的网络日志WebSocket简单介绍 - 肥宅兜 - 博客园 HTTP1.0HTTP1.0的使用的是短连接，每次请求都需要经过三次握手建立一个TCP连接，四次握手断开连接。 HTTP1.1HTTP1.1提升性能的手段1.持久连接 （keep-alive/persistent connection）2.并行连接3 流水线（Pipelining） 持久连接HTTP1.1开始默认建立的是持久连接（有时叫长连接），即一旦浏览器发起HTTP请求，建立的连接不会请求应答之后立刻断掉。一个连接可以不断传输多个HTTP请求，但是如果上一个请求的响应还未收到，则不能处理下一个请求。 注意：在HTTP1.1中默认开启Connection： keep-alive。 参考：关于HTTP1.1的长连接 - CSDN博客 并行连接按照默认设定，一个连接中的每一个请求必须等待收到响应后才能发送下一个请求，所以如果复数的资源请求全部在一个连接one by one发送给服务器显然会很慢，而为了弥补这一缺陷，浏览器通常会默认开启多个TCP连接，然后再根据每个连接的状态在其中依次发送数据请求，而且客户端有权任意关闭超发的连接。12345678910Firefox 2: 2Firefox 3+: 6Opera 9.26: 4Opera 12: 6Safari 3: 4Safari 5: 6IE 7: 2IE 8: 6IE 10: 8Chrome: 6 流水线（Pipelining）可以在一个连接中发送多个请求不必等待前一个请求返回。但这项技术比较容易踩坑，所以主流面向用户的浏览器，这项技术是被默认关闭。 HTTP1.1存在效率问题如上面所说，在HTTP1.1中是默认开启了Keep-Alive，他解决了多次连接的问题，但是依然有两个效率上的问题： 串行的文件传输。当请求a、b文件时，b文件只能等待，必须等a文件传输完成后，b文件才能传输，独占了网络。 连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。 HTTP2HTTP/2有四大特性：二进制格式（Binary Format）、头部压缩、服务端推送(Server Push)、多路复用。 多路复用（MultiPlexing）即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 服务端推送（server push）同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用H2。 注意：HTTP/2引入了服务器推送，它使服务器能够主动发送资源到客户端缓存。但是，它并不允许将数据推送到客户端应用程序本身。服务器推送只能由浏览器处理，并且不会在应用程序代码中弹出，这意味着应用程序没有API来获取这些事件的通知。 HTTP1.1存在效率问题 对于第一个问题：能够把HTTP消息分解成交错的帧,并在另一端组装它们是HTTP/2中一个非常重要的提高。文件传输不再串行，由于所有请求的消息都可分解，那么某一个请求不用等待别一个请求的结束再发送。 对于第二个问题：HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍！ 参考：HTTP、HTTP2 - wujiaolong - 博客园浅析HTTP/2的多路复用 - 奥巴驴 - SegmentFault 思否Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE-网页端IM开发/专项技术区 - 即时通讯开发者社区!SSE技术详解：一种全新的HTML5服务器推送事件技术-网页端IM开发/专项技术区 - 即时通讯开发者社区!]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java8-lambda]]></title>
    <url>%2F2018%2F08%2F25%2Fjava8-lambda%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[面试整理]]></title>
    <url>%2F2018%2F08%2F25%2Fface%2F</url>
    <content type="text"><![CDATA[年前换工作，进行了面试，准备面试的过程学习到了一些东西，在此整理出来，供大家参考。 一：算法问题1：各排序及时间复杂度（必问） 冒泡排序 合并排序 快速排序 最坏时间复杂度 n2 nlog(n) n2 最好时间复杂度 n2/n nlog(n) nlog(n) 平均时间复杂度 n2 nlog(n) nlog(n) 最坏空间复杂度 1 n log(n) 上面表格中，为了便于输入，n2表示n的2次方有些公司（美团、小米）会让写代码，一般能写出快排就行了。 Big-O Algorithm Complexity Cheat Sheet (Know Thy Complexities!) @ericdrowell代码如下：冒泡排序 - 简书快速排序 - 简书归并排序 - 简书 2：链表反转（有些公司会让手写）单链表反转总结篇 - BYRHuangQiang - 博客园 3：动态规划动态规划问题有很多，这里只讨论两个问题： 取子数组的最大和 01背包问题动太规划 - 简书其它算法参考五大常用算法总结 - changyuanchn的专栏 - CSDN博客3：树结构（了解即可）树结构 - 简书3：Paxos算法（加分项）本人总结在系统一致性 - 简书中的『 2.3 分布式数据一致性的研究现状 』一章，由于paxos相对较为复杂，可参考论文及其它网上资源Paxos 算法浅析 - 简书Raft 为什么是更易理解的分布式一致性算法 - mindwind - 博客园架构师需要了解的Paxos原理、历程及实战&amp;version=11020201&amp;pass_ticket=bhstP11nRHvorVXvQ4pt9fzB9Vdzj5sSRBe84783gsg%3D) 二：JAVA基础1：String 类的intern方法深入解析String#intern - 2：Hashmap为什么线程不安全，及put过程，扩容过程，死循环产生的过程（必问）HashMap实现原理 - 简书参考：疫苗：Java HashMap的死循环 | | 酷 壳 - CoolShellHashMap多线程死循环问题 - CSDN博客注意：HashMap 、ConcurrentHashMap 是看源码最好的入门，有数组、链表、红黑树，最好通读下源码。 3：java自带的的分析问题工具jmapjvisualvmjconsoleJstack简单使用，定位死循环、线程阻塞、死锁等问题高手是怎么使用jstack精确找到异常代码的_百度经验《深入理解Java虚拟机》读书笔记3：虚拟机性能监控与调优实战 | GinoBeFunny 4：如果系统宕机，可以通过分析jvm中的内存对象，查找问题 jvm设置:-XX:+HeapDumpOnOutOfMemoryError —宕机时dump生成的.hprof文件 用工具分析:内存分析工具MAT(Memory Analyzer Tool)、IBM HeapAnalyzer5：jdk1.8新特性Java 8 简明教程 · Java 8简明教程6.内存结构和垃圾回收算法及垃圾回收器适用场景jvm总结 - 简书7：多线程问题多线程的问题范围比较多，这里列出常面试的两点：1、线程池原理及怎么设置更合理线程池的两个参数解释（注意：maximumPoolSize是在队列满时才会以此为最大数创建新线程）：corePoolSize：线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。设置线程池大小设置线程池大小要考虑是cpu密集型还是io密集型，精细化设置的话还要考虑：线程等待时间、线程CPU时间。如何合理设置线程池大小 - CSDN博客 2、关键字及工多线程工具类ThreadLocal：Java面试必问，ThreadLocal终极篇volatile:面试必问的volatile，你了解多少？ - 简书CountDownLatch/CyclicBarrier/Semaphore 8：NIO AIO问题实际工作中很少直接使用NIO，面试时问NIO很多情况下会引入netty，netty除了网上相关资料（推荐「占小狼的博客」），可以看『netty权威指南』和『netty实战』 springIoc aop原理待整理 拦截器是怎么实现待整理 Spring事务传播机制网上很多 MybatisMybatis与$与#区别（容易记反）浅谈 Mybatis中的 ${ } 和 #{ }的区别 - 大头就是我 - 博客园 中间件应用1：分库分表如何分库分表及sharding-jdbc分库分表后如何实现分页：sharding-jdbc 按时间分库分表 - 简书 2：dubbo原理和热部署参考dubbo官网Overview | DUBBO 3：zookeeper选举算法及分布式锁实现参考在系统一致性 - 简书中的『 2.3.2 Paxos实践应用-&gt;ZAB协议-&gt;选主阶段（Leader election）』一章排它锁：建临时节点同享锁：建临时顺序节点（具体可参考&lt;从paxos到zookeeper&gt;一书） 4：redis数据结构及分布式锁的实现方式redis分布式锁实现 - 简书单机实现：通过set命令加NX/PX参数实现加锁jedis.set(lockKey, requestId, “NX”, “PX”, expireTime);requestId：可为UUID，删除时使用通过del命令解锁：String script = “if redis.call(‘get’, KEYS[1]) == ARGV[1] then return redis.call(‘del’, KEYS[1]) else return 0 end”;Lua脚本调用保证命令的原子性通过判断requestId（可为UUID），是否为本线程，防止其它线程误删。集群实现：Redlock算法：类似paxos算法，拥有N个Redis master节点的集群，只有超过半数的结点获取锁成功后，认为锁成功。Distributed locks with Redis – Redis《Redis官方文档》用Redis构建分布式锁 | 并发编程网 – ifeve.com 5：mq如何保证不丢失消息mq信息要固化到硬盘或数据库可参考系统一致性 - 简书中的『 2.2.5事件驱动模式 』一章 6：更新缓存与db同步缓存与db属于不同的两个系统，我们知道绝对的数据一致性是不可以的，重点是如何保证最终的一致性，而不影响使用缓存和db的读写先后问题网上有很多讨论，实际应用中各种方式都有，可以确定的原则有两点：1、为了防止空值信息每次都击穿缓存到数据库，增加NullObject(空对象）：如果一个查询在缓存中没有，在数据库中也没有，这样每次都会对击穿数据库进行查询，造成DB负载过大2、尽量设置过期时间，缓存资源有限，防止无效数据一直占用资源。当然也看到有些特例，有些场景面要让数据一直在缓存中，可能通过定时任务，在缓存失效前重置失效时间。 7：Redis与Memcached区别：1: Memcached 只支持key/value；Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 redis 哈希（散列）： 相当于hashmapeg:HSET key field value(HSET car price 500)redis 列表： 相当于 对队queueeg:LPUSH key value(LPUSH numbers 1)redis 集合： 相当于seteg:SADD key member (SADD letters a)redis 有序集合：相当于sorted set:加入分数，通过散列表和跳跃表实现eg:zadd key score member(ZADD scordboard 89 tom) 2: 在Redis中，并不是所有的数据都一直存储在内存中的，Memcached是。3：redis可以定期保存到磁盘（持久化），Memcached不能。4：Memcached是多线程，非阻塞IO复用的网络模型，Redis使用单线程的IO复用模型。还有其它区别，具体搜索网上资料 数据库mysql不同引擎的区别，数据结构，事务隔离级别以及如何实现隔离数据库隔离级别 - 简书 其它sql优化、索引、组合索引相关 前端：一般做后端的前端都较弱，所有在面试官在问前端知识时，你可以回答解题的思路，具体函数名、参数什么的网上搜索相关开发手册就行。 js闭包这里特别提下闭包，毕竟这点跟java有很大区别Javascript闭包——懂不懂由你，反正我是懂了知识库博客园Java8闭包 - yanweiqi - 博客园闭包(Java中的闭包) - CSDN博客 开放性问题：1、看了哪些书2、遇到哪些难题，怎么解决的3、哪方面你最擅长，讲一下/你有什么优势这些问题较为开放，面试次数多了就有经验了，不过尽量还是提前组织一下语言。 推荐推荐书籍： java并发编程实战（重理论） java并发编程的艺术（重使用） spring源码深度解析 Spring实战(Spring Boot实战） 重构 代码整洁之道还有其它书籍，但这几本看时最为舒畅，本人以为好的书满足两个条件：一是问题讲清楚，二是用最简单的方式进行讲述。这几本满足这两个条件。网站及博客推荐一个网站、一个博客，特别是占小狼的博客，里面即有技术的总结，还有一些方法的推荐，有空尽量都过一遍：https://tech.meituan.com/占小狼 - 简书]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2018%2F08%2F25%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo搭建相对简单，并且有丰富的主题。 环境准备 安装node1234567nodejs安装1、访问nodejs官网，点击蓝色选框区域稳定版，并下载https://nodejs.org/en/2、安装完成后打开终端，输入 npm -v node -v 两个命令，如下图出现版本信息，说明安装成功。 Node.js 安装配置 | 菜鸟教程 安装hexoHexo 常用命令1234567891011$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot;#新建页面常用简写$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy$ hexo d -g #生成部署$ hexo s -g #生成预览 更改主题123451、下载主题到themes/next目录git clone https://github.com/theme-next/hexo-theme-next themes/next2、修改_config.yml主题设置theme: next3、进入站点根目录/themes/next/_config.yml Hexo的Next主题详细配置 - 简书 设置sshhttps://github.com/settings/keys 绑定域名： 申请域名域名注册虚拟主机云服务器_企业邮箱-万网-阿里云旗下品牌 http://lesline.top.com/http://lesline.github.io/ 增加文件：/Users/zhangshaolin/git/hexo/blog/source/CNAME1lesline.top blog配置文件_config.yml下1234deploy: type: git repo: git@github.com:lesline/lesline.github.io.git branch: master 问题：Hexo Next 更换scheme，本地查看成功，部署后访问依然未变化？先clean 再deployhexo cleanhexo ghexo d 参考：Category: hexo干货系列 | 嘟嘟独立博客手把手教你使用Hexo + Github Pages搭建个人独立博客 | 令狐葱@前端笔记]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GIT 分支管理]]></title>
    <url>%2F2018%2F08%2F09%2Fgit-branch%2F</url>
    <content type="text"><![CDATA[本文参考阿里与京东的分支管理做了一下整理。 参考：在阿里，我们如何管理代码分支？GitHub Flow &amp; Git Flow 基于Git 的两种协作开发模式 - sloong - 博客园 TrunkBased 模式：持续集成What is Trunk-Based Development?谷歌的代码管理 - 阮一峰的网络日志 TrunkBased 模式是持续集成思想所崇尚的工作方式，它由单个主干分支和许多发布分支组成，每个发布分支在特定版本的提交点上从主干创建出来，用来进行上线部署和 Hotfix。不能满足多版本并行开发，主要用在不需要同时维护多个历史版本的 SaaS 型项目，特别是经过微服务改造的各种小型服务上。OneFlow 模式：参考了 TrunkBased 的许多思想，对操作流程做了更严格的定义，增加了 Hotfix 分支等内容。多主干模式：通常是双主干，固定的开发分支和固定的发布分支，算是 TrunkBased 采用固定发布分支的特例。GithubFlow 模式：在 TrunkBased 的基础上，增加了个人仓库和 Pull Request 合并代码的操作。 GitFlow模式：管理需求深入理解学习Git工作流（git-workflow-tutorial） - 程序生涯 - SegmentFault 思否GitFlow模式相对强大： 应用一：1 master分支主分支，产品的功能全部实现后，最终在master分支对外发布。2 develop分支开发分支，基于master分支克隆，产品的编码工作在此分支进行。3 release分支测试分支，基于delevop分支克隆，产品编码工作完成后，发布到本分支测试，测试过程中发现的小bug直接在本分支进行修复，修复完成后合并到develop分支。本分支属于临时分支，目的实现后可删除分支。4 bugfix分支Bug修复分支，基于master分支或发布的里程碑Tag克隆，主要用于修复对外发布的分支，收到客户的Bug反馈后，在此分支进行修复，修复完毕后分别合并到develop分支和master分支。本分支属于临时分支，目的实现后可删除分支。5 feature分支功能特征分支，基于develop分支克隆，主要用于多人协助开发场景或探索性功能验证场景，功能开发完毕后合并到develop分支。feature分支可创建多个，属于临时分支，目的实现后可删除分支。 主要问题有：::1、如果测试后不上线，Develop分支与线上分支不一致，如果需要develop分支与master一致就需要频繁重建develop分支或回滚。::::2、另外release merge到Master时，代码冲突严重。:: 应用二：与应用一的区别是：建立发布分支用于发布，发布后合并master。1、共一个主干分支master2、N个特性分支==N个发布分支（特性分支开发完成后，直接转测，直接转为发布分支）3、不定期的更新主干分支 主要问题有：::1、主干分支常常跟不上线上环境的代码::::2、大量的合并突冲，集成测试不友好:: TrunkBased与GitFlow比较：优点： TrunkBased “易于持续集成” ; GitFlow “易于管理需求” 缺点：TrunkBased缺点：不能很好支持多版本的并行开发GitFlow的问题：合并冲突 阿里分支管理AoneFlow 在 AoneFlow 上你能看到许多其他分支模式的影子。它基本上兼顾了 TrunkBased 的“易于持续集成”和 GitFlow 的“易于管理需求”特点，同时规避掉 GitFlow 的那些繁文缛节。 1、开始工作前，从主干创建特性分支。 2、通过合并特性分支，形成发布分支。 3、发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支关联的特性分支。 京东分支管理：分支分类：master：主分支，与线上保持一致。永久保留。dev：开发分支，相对稳定分支。永久保留。dev分支与master强一致dev-pretest ： 测试和预上线分支，必要的时候删除从dev拉取。feat-人名全拼或者姓名首字母-功能描述： 功能分支。如; feat-sunweiwei-cancelorder或者feat-sww-cancelorder，标注开发人员+该分支的功能。用完即删。hotfox-人名全拼或者姓名首字母-功能描述：线上bug修复分支。如：hotfix-sunweiwei-orderpay或者feat-sww-orderpay，标注开发人员+该分支处理的问题。用完即删。分支名称统一都是小写字母。 京东与阿里的比较相同：都从主干拉取分支，再合并特性分支，减少了合并冲突不同：京东是直接在master分支上发布，阿里是新建发布分支，发布成功后合并到master，两种方式导致的结果是：阿里支持“修改历史版本bug”的功能，京东不支持。 ::总的来说，京东偏向TrunkBased 模式，阿里偏向Gitflow模式，由于京东模式缺少明确的发布分支，只在主干分支上发布，导致不支持多版本，如果要修改历史版本的bug，只能升级到最新版本。:: 总结：::1、对于微服务中小型服务（或只是一个jar工具包），这种修改后立刻可以上线使用，且不影响线上服务的情况，用TrunkBased 模式即可::::2、如果系统不支持多版本修复（需要修复升级到最新版本即可），使用京东方式即可。如果有多版本支持使用阿里方式。:: 以上讨论基于如下需求：1、多功能同时测试2、测试后可能不上线]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo_plug]]></title>
    <url>%2F2018%2F08%2F09%2Fhexo-plug%2F</url>
    <content type="text"></content>
  </entry>
</search>
